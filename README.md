<br/>
<h1 align="center">Engangled ‚áù IO</h1>

<p align="center">Spooky <code>action()</code> at a distance. üßô‚Äç‚ôÇÔ∏è</p>

<br/>

> Documentation is a work in process; more to come soon!

<br/>

<p align="center">Entangled-IO is a set of developer tools designed to bridge the gap between client and server applications written in typescript. With simple helpers on the backend, and webpack-plugin on the front, you can effectively call server-side functions as if they were defined locally within your apps in the field.</p>

<br/>

## Installation

> For your server application, using express.
```
npm install @entangled/express
npm link
```

> For your client application, using webpack.
```
npm install @entangled/webpack
npm link my-service
```

<br/>

## Base Concept

Entangled, when paired in a client and server app using typescript, abstracts away matters of transport. At build time, it will generate matching resources and adaptors for you, following a simple map of functions you'd define anyway in your business logic. 

For linked projects, this technique uses webpack to scan a client build for what would otherwise be [illegal imports](https://i.kym-cdn.com/entries/icons/original/000/028/207/Screen_Shot_2019-01-17_at_4.22.43_PM.jpg) (as they can't actually be bundled). Instead, your app knows to fetch from an endpoint, resources which proxy your actual functions. 

*This makes interop essencially free; masquerading as easy-to-use async functions.*

### TL;DR

- Call remote business logic directly from the client
- Skip explicitly writing REST handlers for your server
- Access resources as functions, not requests
- No need to pack or unpack complex data
  > Arguments and returned data are serialized and reassembed for you on both sides, so deeply nested objects and arrays are always safe and easy to send and recieve. <br/>
- Special objects don't need to be stringified
  > Handing off `Date` for instance has always been tedius, but here it's automatic. <br/>
  > No more `let d = date && new Date(date);` nonsense! <br/>
  > `Map` & `Set` are also in the works; arbitary class types too eventually.
- **Type signatures are preserved!** 
  > Because you simply "import" actual server functions, your IDE remains aware of their signature, so autocomplete and error detection won't have any blind-spots. üëÄ
- Errors thrown by the server (in development) are merged with ones consequently thrown on the client
  > Sometimes, it can be inconvenient or even impossible to inspect console output from where your functions are running, such as within a container or part of a cluster. This helps make that a non-issue. <br/><sub>&nbsp;(TBR, but I'm working on it!)</sub>

<br/>

Ultimately, you can focus more on the business logic of your stack, rather than the api itself. <br/> This way, both can grow organically with little in the way of debugging and type maintainance.

<br/>

## Setup

It takes very little to get up and running. Start by linking your node app (using preference of [NPM](https://www.deadcoderising.com/how-to-smoothly-develop-node-modules-locally-using-npm-link/) or [Yarn](https://classic.yarnpkg.com/en/docs/cli/link/)) to client apps. A good practice is to add it as a dev-dependancy as well. 

> [Lerna](https://github.com/lerna/lerna) and/or [yarn-workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) can be used to accomplish the same thing if you're into monorepos!
> 
> However, while not necessary, configuring server modules with a [Typescript project reference](https://www.typescriptlang.org/docs/handbook/project-references.html) is a good idea. It causes your IDE's language-server to consider the actual `src/` of your project for types, rather than `d.ts` files generated by a build. This can greatly enhanse the responsiveness of your type-checker, and assist with procedures (such as `Rename Symbol`).

**Remember**: *Declarations are required* for both development and production builds, of any server module used.

<br/>

## Hello World

The following is pretty much all you'll need to implement a simple round trip between node and a browser application.

<br/>

Let's make us a sever which can say hi.  üëã

> `my-service/index.ts`

```typescript
/* First import a helper for whatever platform you're using. */

import Interface from '@entangled/express';

/* Define your functions to do or return whatever you like. */

async function sayHi(name = "World"){
  return `Hello ${name}!`
}

/* Create an interface with a map of functions you wish to expose.
   You can organize them too, into routes, via nesting! */

const api = new Interface({ sayHi });

/* Launch the resulting interface as an endpoint for runtime.
   Here, `listen` will create an Express instance for you (and route to "/")
   You can spread into an existing express app, if you want to, though! */

api.listen(8080); 

/* Lastly, expose the generated namespace for consumers to access. */

export = api; 
```

<br/>

Now on to the app. Add your service as a **dev-dependancy** and remember to `link` it to the client.

> `my-app/package.json`

```json
{
  "name": "my-app",
  "devDependancies": {
    "my-service": "0.0.0"
  }
}
```

<br/>

Add the entangled replacement-plugin to webpack; passing in the name of any imports exposing an API.

> `my-app/webpack.config.js`

```js
const ApiReplacementPlugin = require("@entangled/webpack");

module.exports = {
  plugins: [
    new ApiReplacementPlugin(["my-service"])
  ]
}
```

<br/>

Now you can import and use your server-side functions ‚úåÔ∏èlocally ‚úåÔ∏è!

> `my-app/app.tsx`

```tsx
/* Import the servce module and interface we've made there. */

import API from "my-service"

async function sayHello(e: MouseEvent){
  const name = prompt("What is your name?", "World");

  /* Call and await the remote-function like you would any other thenable!
     It will fetch the corresponding resource (invoking your function) under the hood. */

  let response = await API.sayHi(name);

  /* Oh, and you might notice we still have type inference, even within .js files! üòç */

  e.currentTarget.innerText = `Server said: ${response}`;

  /* Enjoy your day ‚òïÔ∏è */
}

export default () => (
  <div onClick={sayHello}>
    Click me to say hi to the server!
  </div>
)
```
<br/>

> Note: [`esModuleInterop`](https://stackoverflow.com/a/56348146) is set to true for this module, which substitues `*` for `default`. <br/> You might like to destructure your functions/routes instead, which should be the norm for larger API's.

<br/>

And that's it!

<br/>

## So why does this work?

This works because, having crawled your provided functions, `@entangled/express` defined the route: <br>
`POST //host:8080/sayhi` on whatever backend you've setup.

At the same time, a copy of `@entangled/client` was injected in place of `my-service`, exporting `*` which contains
```ts
{ sayHi: (name?: string) => Promise<string> }
```

When called, the runtime goes to work to bundle and send your arguments (if any) to a matching resource.

If all goes well, your Express backend receives the request, to then reformat and `apply` to your original function. <br/> 
Much the same occures for the response, and *voila* the client's promise resolves the returned value!

And all of your glue-code? üëã`‚§µ`<br/> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;üóë

<br/>

## Packages at work

### `@entangled/webpack`

> This plugin lets webpack consume some dependancy (better put, a devDependancy) as a remote module. Webpack wil scan that import for type definitions `d.ts` of your server module. An adaptor is then injected which will replace those exports using `fetch` calls, all to resources corresponding to those functions.

### `@entangled/fetch`

> A client adaptor for your browser apps. Webpack relies on this for serialization and to plug-in to the real endpoint exposing your exported functions for use.

### `@entangled/interface`

> Webpack and the server adaptor relies on this to discover and parse `d.ts` files in order to properly mirror your IO. It tries to be aware of your actual arguments' types for purposes of conversion and error detection (coming soon). This is also most-importantly responsible for conveying TS bindings to consumers properly.

### `@entangled/express`

> Consuming an arbitarily deep map of functions, this plugin (specifically for express apps) will expose those functions as an endpoint for the client-adaptor to bind to at run-time.


<br/>

## Try it out! 

> Provided is an exmaple you can try out for yourself!

```
git clone git@github.com:gabeklein/entangled-io.git
cd entangled-io
npm install
npm run example
```

> This will launch both a server (on port 8080) and dev-server (port 80) for the client, demoing a simple interaction you can play with!

<br/>

## License

MIT

<br/>

## Contributions

<sub>plz.</sub>
