<br/>
<h1 align="center">Engangled ‚áù IO</h1>

<p align="center">Spooky <code>action()</code> at a distance. üßô‚Äç‚ôÇÔ∏è</p>

<br/>

> Documentation is a work in process, so more to come soon!

<br/>

<p align="center">Entanged-IO is a set of dev tools designed to bridge the gap between a client and server applications written in typescript. With a simple helper on the backend, and webpack-plugin on the front, you can effectively call server-side functions as if they were locally defined within your apps.</p>

<br/>

## Installation

> In your server application using express.
```
npm install @entanged/express
npm link
```

> In your client application, using webpack.
```
npm install @entanged/webpack
npm link my-service
```

<br/>

## Usage

It takes very little to get up and running, start by linking your node-app using [NPM](https://www.deadcoderising.com/how-to-smoothly-develop-node-modules-locally-using-npm-link/) or [Yarn](https://classic.yarnpkg.com/en/docs/cli/link/) to your clients. Good practice is to list it as a dev-dependancy as well. 

> [Lerna](https://github.com/lerna/lerna) and/or [yarn-workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) can also be used to accomplish the same thing, if you're into monorepos!
> 
> However, while not necessary, configuring the server module with a [Typescript project reference](https://www.typescriptlang.org/docs/handbook/project-references.html) is also a good idea. It causes your IDE's language-server to consider the `src/` directories of your project for types, rather than the `d.ts` files generated by tsc. This can enhanse the responsiveness of type-checking and help batch operations (like `Rename Symbol`).

***Remember**: Some form of declarations must be on for both development and production builds of your server modules.*

<br/>

### A simplified example

> `my-service/index.ts`

While there are better ways to structure your app, we'll cram everything into just one file for now.

```typescript
// Import the appropriate REST helper for whatever platform you are using.

import Interface from '@entangled/express';

// Define functions to do or return whatever you like.

async function sayHi(name = "World"){
  return `Hello ${name}!`
}

// Create resources via a map (object) of those functions;
// you can organize them too, into routes, using nested objects.

const api = new Interface({ sayHi });

// Expose the resulting interface as an endpoint for use during runtime.
// Here `listen` will create the Express instance for you (and bind to "/")
// Entanged can also be spread into an existing express app though!

api.listen(8080); 

// Finally, expose the interface for consumers to easily import. 

export = api; 
```

<br/>

Next step is to add the replacement-plugin to your webpack config and pass the name of package you wish to bridge.

> `my-app/webpack.config.js`

```js
const ResourceReplacementPlugin = require("@entangled/webpack")

module.exports = {
  plugins: [
    new ResourceReplacementPlugin(["my-service"])
  ]
}
```

<br/>

> `my-app/app.tsx`

```tsx
// Import the interface we created.

import API from "my-service"

async function sayHello(e: MouseEvent){
  const name = prompt("What is your name?", "World");

  // Call and await the request like you would any other thenable.
  // It will `fetch` your corresponding resource (invoking the function) under the hood. ‚ö°Ô∏è

  let response = await API.sayHi(name);

  // Oh, and when using TS, you'll notice you still have 
  // the signature `sayHi(name?: string): Promise<string>`!

  e.currentTarget.innerText = `Server said: ${response}`;

  // Enjoy your day 
}

export default () => (
  <div onClick={sayHello}>
    Click me to say hi to the server!
  </div>
)
```
<br/>

> Note that [`esModuleInterop`](https://stackoverflow.com/a/56348146) here is set to true for this client, which substitues `*` for `default`. <br/> You can also destructure your functions and/or routes, which should be the norm for larger API's.

### Synopsis

This works because having crawled the provided map, `@entangled/express` defined the route: <br>
`POST //host:8080/sayhi`

Via webpack, `@entangled/client` was injected to export `API` which itself defines 
`sayHi(name)`. <br/> When called, arguments are bundled and sent as a request your endpoint.

Express recieves the request, forwarding it to the enganged runtime to parse and invoke to your original function with. <br/> 
The response is handled in much the same way, and *voila* client's promise resolves the returned value!

And all of your glue-code: ‚§µ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üóë

<br/>

## Advantages
- You don't need to define REST resources ever, this is automagic.
- You don't need to consume REST resources ever, this is also automagic.
- You don't need to pack or unpack complex data, this is in-addition automagic.
  > Complex structures are serialized/deserialized for you. You may send objects as both arguments and the return-type; they are reassembed on both sides, so deeply nested `{}`, `[]` are welcome. <br/>
- Special objects do not need to be stringified. Converting `Date` for instance can be super tedius, but here it's free.
  > `Map` `Regex` `Set` are in the works, rehydration of arbitary class types too eventually.
- Type signatures are preserved! Because you're simply importing functions, your IDE remains aware of interfaces, so autocomplete and error checking won't have any blind-spots. 
- Errors thrown by server in development mode are added to the stack trace of any failed promise, on the client. 
  > This is especially useful when it is inconvenient or impossible to watch console output where your functions are actually running (on the cloud). Thhis feature is unstable but working on that!
- Ultimately, this just lets you focus on the business logic of your app, over transport and the structure for your api's. <br/>They can grow for-the-most-part organically. 

<br/>

## Packages

### `@entangled/webpack`

> Add this plugin to your webpack build to consume some dependancy (better put, a devDependancy) as a remote module. Webpack wil scan that import for type definitions `d.ts` of your server module. An adaptor is then injected which will mirror the exports of your "fake" import using `fetch` calls, all to appropriate resources corresponding to your functions.

### `@entangled/fetch`

> A client adaptor for your browser app. Webpack relies on this for serialization and to plug-in to the real endpoint exposing your exported functions for use.

### `@entangled/interface`

> Webpack and the server adaptor relies on this to discover and parse `d.ts` files in order to properly mirror your IO. It tries to be aware of your actual arguments' types for purposes of conversion and error detection (coming soon). This is also most-importantly responsible for conveying TS bindings to consumers properly.

### `@entangled/express`

> Consuming an arbitarily deep map of functions, this plugin (specifically for express apps) will expose those functions as REST endpoints for the client-adaptor to bind to at run-time.


<br/>

## Try it out! 

> Provided is an exmaple you can try this out for yourself!

```
git clone git@github.com:gabeklein/entangled-io.git
cd entangled-io
yarn install
yarn start
```

> This will lanch 